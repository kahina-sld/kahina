package org.kahina.core.io.util;

import java.awt.Color;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringWriter;
import java.util.LinkedList;
import java.util.List;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

public class XMLUtilities 
{
	/**
	 * parse an XML file
	 * 
	 * @param f
	 *            the XML file
	 * @param validating
	 *            toggle validation
	 * @return the parsed document
	 */
	public static Document parseXMLStream(InputStream s, boolean validating) 
    {
		try 
        {
			DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            factory.setNamespaceAware(true);
			factory.setValidating(validating);
			DocumentBuilder builder = factory.newDocumentBuilder(); 
			//builder.setEntityResolver(new MyEntityResolver());
			Document ldoc = builder.parse(s);
			ldoc.normalize();
			return ldoc; 
		}
        catch (SAXParseException spe) 
        {
			// Error generated by the parser
			System.err.println("\n** Parsing error" + ", line " +
			spe.getLineNumber() + ", uri " + spe.getSystemId());
	        System.err.println("   " + spe.getMessage());
	            		        
		}
        catch (SAXException sxe) 
        {
			// Error generated during parsing
			System.err.println("   " + sxe.getMessage());
		} 
        catch (ParserConfigurationException e) 
        {
			// Parser with specified options can't be built	
			System.err.println("   " + e.getMessage());
		} 
        catch (IOException e) 
        {
			// I/O error
			System.err.println("   " + e.getMessage());
			//e.printStackTrace();
		}
		return null;
	}
	
	public static Document newEmptyDocument()
	{
		try
		{
			DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
			DocumentBuilder builder = factory.newDocumentBuilder();
		
			Document doc = builder.newDocument();
			return doc;
		}
		catch (ParserConfigurationException e)
		{
			System.err.println("WARNING: Generation of empty XML document failed! Returning NULL!");
			return null;
		}
	}
	
	/**
	 * Generates an XML file at a specified path containing the contents of a DOM node
	 * @param node - the DOM node whose content is output into the file
	 * @param outfile - the path to the XML file that is to be generated
	 */
	public static void writeXML(Node node, String outfile) 
    {
		try 
        {
			DOMSource domSource = new DOMSource(node);
			StringWriter writer = new StringWriter();
			StreamResult result = new StreamResult(writer);
			TransformerFactory tf = TransformerFactory.newInstance();
			tf.setAttribute("indent-number", new Integer(2));
			
			Transformer transformer = tf.newTransformer();
			transformer.setOutputProperty(OutputKeys.INDENT, "yes");
			/**if (system) 
            {
				transformer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, dtd);
			} 
            else 
            {
				transformer.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, dtd);
			}**/
			
			transformer.transform(domSource, result);
			String stringResult = writer.toString();
			
			if (outfile.equals("stdout")) 
            {
				System.out.println(stringResult);
			} 
            else 
            {
				FileWriter fw = new FileWriter(outfile);
				fw.write(stringResult);
				fw.close();
			}
			
		} 
        catch (TransformerException e) 
        {
			System.err.println("   " + e.getMessage());
		} 
        catch (IOException e) 
        {
			// I/O error
			System.err.println("   " + e.getMessage());		
		} 
        catch (Exception e)
        {
			System.err.println("   " + e.getMessage());		
		}
	}
	
	public static boolean attrBoolVal(Element el, String attrName)
	{
		return Boolean.parseBoolean(el.getAttribute(attrName));
	}
	
	/**
	 * Constructs a color from an attribute value in an XML document.
	 * Expects the color to be encoded as color(R,G,B).
	 * Outputs an informative error message and returns Color.WHITE on error.
	 * @param el the element whose attribute we access
	 * @param attrName name of the attribute whose value encodes the color
	 * @return the color at the specified element and attribute
	 */
	public static Color attrColorVal(Element el, String attrName)
	{
		String colorString = el.getAttribute(attrName);
		if (!(colorString.startsWith("(") && colorString.endsWith(")")))
		{
			System.err.println("ERROR: color descriptions must be in brackets!");
			return Color.WHITE;
		}
		colorString = colorString.substring(1,colorString.length() - 1);
		String[] values = colorString.split(",");
		if (values.length != 3)
		{
			System.err.println("ERROR: color descriptions must consist of three comma-separated integers!");
			return Color.WHITE;
		}
		int red = Integer.parseInt(values[0]);
		int green = Integer.parseInt(values[1]);
		int blue = Integer.parseInt(values[2]);
		return new Color(red,green,blue);
	}
	
	public static int attrIntVal(Element el, String attrName)
	{
		return Integer.parseInt(el.getAttribute(attrName));
	}
	
	public static String attrStrVal(Element el, String attrName)
	{
		return el.getAttribute(attrName);
	}
	
	public static List<Element> getElements(Element el, String elName)
	{
		LinkedList<Element> children = new LinkedList<Element>();
		NodeList nl = el.getElementsByTagName(elName);
		for (int i = 0; i < nl.getLength(); i++)
		{
			children.add((Element) nl.item(i));
		}
		return children;
	}
	
	public static List<Element> getChildElements(Element el)
	{
		LinkedList<Element> children = new LinkedList<Element>();
		NodeList nl = el.getChildNodes();
		for (int i = 0; i < nl.getLength(); i++)
		{
			if (nl.item(i).getNodeType() == Node.ELEMENT_NODE)
			{
				children.add((Element) nl.item(i));
			}
		}
		return children;
	}
	
}
